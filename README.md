Структура данных в программе:  
Один вектор (clauses) отвечает дизъюнктам(клаузам), его i-ый элемент содержит i-ую строку из файала с переменными или их отрицаниаями (всего элементов в векторе n+1)  
Второй вектор (var), i-ый элемент хранит все себе номера всех клауз в которых есть переменная i. И если в этой клаузе i-ая переменая с отрицанием, то храниться отрицательный номер (всего элементов в векторе n+1)  

Например для файла uf20-01.cnf из набора uf20-91 эти два вектора выглядят так  
Вектор clauses  
claus[1]   4 -18 19   
claus[2]   3 18 -5   
claus[3]   -5 -8 -15   
claus[4]   -20 7 -16   
claus[5]   10 -13 -7   
claus[6]   -12 -9 17   
claus[7]   17 19 5   
claus[8]   -16 9 15   
claus[9]   11 -5 -14   
claus[10]   18 -10 13   
claus[11]   -3 11 12   
claus[12]   -6 -17 -8   
claus[13]   -18 14 1   
claus[14]   -19 -15 10   
claus[15]   12 18 -19   
claus[16]   -8 4 7   
claus[17]   -8 -9 4   
claus[18]   7 17 -15   
claus[19]   12 -7 -14   
claus[20]   -10 -11 8   
claus[21]   2 -15 -11   
claus[22]   9 6 1   
claus[23]   -11 20 -17   
claus[24]   9 -15 13   
claus[25]   12 -7 -17   
claus[26]   -18 -2 20   
claus[27]   20 12 4   
claus[28]   19 11 14   
claus[29]   -16 18 -4   
claus[30]   -1 -17 -19   
claus[31]   -13 15 10   
claus[32]   -12 -14 -13   
claus[33]   12 -14 -7   
claus[34]   -7 16 10   
claus[35]   6 10 7   
claus[36]   20 14 -16   
claus[37]   -19 17 11   
claus[38]   -7 1 -20   
claus[39]   -5 12 15   
claus[40]   -4 -9 -13   
claus[41]   12 -11 -7   
claus[42]   -5 19 -8   
claus[43]   1 16 17   
claus[44]   20 -14 -15   
claus[45]   13 -4 10   
claus[46]   14 7 10   
claus[47]   -5 9 20   
claus[48]   10 1 -19   
claus[49]   -16 -15 -1   
claus[50]   16 3 -11   
claus[51]   -15 -10 4   
claus[52]   4 -15 -3   
claus[53]   -10 -16 11   
claus[54]   -8 12 -5   
claus[55]   14 -6 12   
claus[56]   1 6 11   
claus[57]   -13 -5 -1   
claus[58]   -7 -2 12   
claus[59]   1 -20 19   
claus[60]   -2 -13 -8   
claus[61]   15 18 4   
claus[62]   -11 14 9   
claus[63]   -6 -15 -2   
claus[64]   5 -12 -15   
claus[65]   -6 17 5   
claus[66]   -13 5 -19   
claus[67]   20 -1 14   
claus[68]   9 -17 15   
claus[69]   -5 19 -18   
claus[70]   -12 8 -10   
claus[71]   -18 14 -4   
claus[72]   15 -9 13   
claus[73]   9 -5 -1   
claus[74]   10 -19 -14   
claus[75]   20 9 4   
claus[76]   -9 -2 19   
claus[77]   -5 13 -17   
claus[78]   2 -10 -18   
claus[79]   -18 3 11   
claus[80]   7 -9 17   
claus[81]   -15 -6 -3   
claus[82]   -2 3 -13   
claus[83]   12 3 -2   
claus[84]   -2 -3 17   
claus[85]   20 -15 -16   
claus[86]   -5 -17 -19   
claus[87]   -20 -18 11   
claus[88]   -9 1 -5   
claus[89]   -19 9 17   
claus[90]   12 -2 17   
claus[91]   4 -16 -5   

Вектор var  
var[1]    13 22 -30 38 43 48 -49 56 -57 59 -67 -73 88   
var[2]    21 -26 -58 -60 -63 -76 78 -82 -83 -84 -90   
var[3]    2 -11 50 -52 79 -81 82 83 -84   
var[4]    1 16 17 27 -29 -40 -45 51 52 61 -71 75 91   
var[5]    -2 -3 7 -9 -39 -42 -47 -54 -57 64 65 66 -69 -73 -77 -86 -88 -91   
var[6]    -12 22 35 -55 56 -63 -65 -81   
var[7]    4 -5 16 18 -19 -25 -33 -34 35 -38 -41 46 -58 80   
var[8]    -3 -12 -16 -17 20 -42 -54 -60 70   
var[9]    -6 8 -17 22 24 -40 47 62 68 -72 73 75 -76 -80 -88 89   
var[10]    5 -10 14 -20 31 34 35 45 46 48 -51 -53 -70 74 -78   
var[11]    9 11 -20 -21 -23 28 37 -41 -50 53 56 -62 79 87   
var[12]    -6 11 15 19 25 27 -32 33 39 41 54 55 58 -64 -70 83 90   
var[13]    -5 10 24 -31 -32 -40 45 -57 -60 -66 72 77 -82   
var[14]    -9 13 -19 28 -32 -33 36 -44 46 55 62 67 71 -74   
var[15]    -3 8 -14 -18 -21 -24 31 39 -44 -49 -51 -52 61 -63 -64 68 72 -81 -85   
var[16]    -4 -8 -29 34 -36 43 -49 50 -53 -85 -91   
var[17]    6 7 -12 18 -23 -25 -30 37 43 65 -68 -77 80 84 -86 89 90   
var[18]    -1 2 10 -13 15 -26 29 61 -69 -71 -78 -79 -87   
var[19]    1 7 -14 -15 28 -30 -37 42 -48 59 -66 69 -74 76 -86 -89   
var[20]    -4 23 26 27 36 -38 44 47 -59 67 75 85 -87   

---

Решил создать вектор с хранением клауз (вектор var), для того чтобы эфективно удалить единчные дизъюнкты и для нахождения переменных которые входят в КНФ либо только с отрицанием, либо только без отрицания.  

Парсинг файла происходит в конструкторе класса.  
Метод get_result() запускает решатель и возвращет SAT или UNSAT.  

single_literal - в момент парсинга здесь сохраняются переменные из единичных дизъюнктов.  
lit_sorted - хранит в себе номер переменной и кол-во дизъюнктов в которой она встречается (размер var[i])  


Решил добавить в программу хэш для того чтобы отслеживать при каких значениях происходят конфликты (сохранял в хэш std::bitset<800> соответсвующий определённому набору)  

Изначально при обратном ходе менял значение верхней переменной из стека уже определённых переменных (decision)   
Простеёшие кнф из трёх дизъюнктов и двух переменных решало.  

Дальше создал вектор (lit_sorted), для того чтобы ручное назначение было не просто по порядку, а в зависимости от частоты переменной в кнф. Чем чаще встречалась, тем раньше она определялась.  
Потом пересмотрел использование хэш, и добавил проверку хэша на бэктрэкинг, предпологал, что так можно будет сразу проверить надо ли выставлять противоположное значние или лучше оставить её неопределённой и изменять переменную на ещё на шаг назад, но это результатов не дало. В итоге просто убрал весь хэш из программы, так как не заметил что он хоть как-то влияет на результат. (особенно когда заранее известно, что все тесты SAT)  
Самым действенным оказалось сохранение уровня. Сохранение той переменной которую выставляли "вручную" и откат всех присвоение, до момента выбора значения этой переменной (откат всех unit-присвоений). (Алгоритм DPLL)  

После этого набор uf150-645 - был побеждён  

Вывод gtest при запуске всех файлов uf150  
[==========] Running 1 test from 1 test suite.  
[----------] Global test environment set-up.  
[----------] 1 test from FileTest  
[ RUN      ] FileTest.CompareWithExpectedOutput  
1 2 3 4 5 6 7 8 9 10   
11 12 13 14 15 16 17 18 19 20   
21 22 23 24 25 26 27 28 29 30   
31 32 33 34 35 36 37 38 39 40   
41 42 43 44 45 46 47 48 49 50   
51 52 53 54 55 56 57 58 59 60   
61 62 63 64 65 66 67 68 69 70   
71 72 73 74 75 76 77 78 79 80   
81 82 83 84 85 86 87 88 89 90   
91 92 93 94 95 96 97 98 99 100   
[       OK ] FileTest.CompareWithExpectedOutput (729133 ms)  
[----------] 1 test from FileTest (729133 ms total)  
    
[----------] Global test environment tear-down  
[==========] 1 test from 1 test suite ran. (729133 ms total)  
[  PASSED  ] 1 test.  

Столкнулся с проблемой при выполнении hanoi4, очень долго считает

Реализовал новый "ручной" выбор, теперь у переменных есть рейтинг. Чем больше рейтинг, тем больше они сдвигаются к началу вектора.  
Тем самым, наиболее конфликтые переменные будут определяться раньше других. При этом, раз в 256 конфликтов все рейтинги деляться на два.  
Это обеспечивает, что со временем некоторые конфликтные переменные забываются.  
Рейтинг увеличивается у одной переменной, которую мы в послдений раз выбирали "вручную".  

Теперь набор uf150-645 считается за 532579 ms.

Но hanoi4.cnf всё ещё не может посчитать даже за 40 минут. Тесты выполнялись на процессоре intel core i7, 7-го поколения.

Стоит попробовать следующие вещи:  
Добавить резолюцию. В hanoi4.cnf 49 переменных, которые входят в кнф либо с только с одним отрицанием, либо только с одним положительным. Тоесть можно сделать резолюцию и после этого удалить все клаузы в которые входит эта переменная, потому что в оставшихся клаузах она будет либо только с отрицанием, либо только положительна. При том что, в среднем одна переменная находится в 12 клаузах.  
Добавить Watched Literals.

И в конечном итоге реализовавыть Conflict-driven clause learning.


Попробовал дсоздать новую эвристику.
Она заключается в добавлении веса тем переменным которые находятся в коротких клаузах.
Цель была в том чтобы вручном присвоении сначала выбирались, те переменные что очень часто встречаются в коротких клаузах, и чтобы было больше unit-лтералов на начальных этапах

Это дало совсем небольшое улучшение на наборе uf150-645 526784 ms.

Изменил увеличение рейтинга при конфликтах. Теперь рейтинг увеличивается у всех переменных что содержаться в клаузе, при которой возник конфликт. Набор uf150-645 считается за 457005 ms.  


Добавил резолюцию, это дало удалить всего 171 клаузу в hanoi4.

Переписал unitPropaget, при каждом опредлении переменной добавляю её в стек, и в функции unitPropaget просматриваю все клаузы, которые эта переменная могла испортить. Нахожу новые watch-переменные и ставлю их на первые два места.

Ссылки на материалы:
https://docs.yandex.ru/docs/view?tm=1743619645&tld=ru&lang=ru&name=sat.pdf&text=%D0%BA%D0%B0%D0%BA%20%D0%BB%D1%83%D1%87%D1%88%D0%B5%20%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BD%D1%84%20%D0%B4%D0%BB%D1%8F%20SAT&url=https%3A%2F%2Falexanderdyakonov.narod.ru%2Fsat.pdf&lr=213&mime=pdf&l10n=ru&sign=867f2be1518868eeb2f0be64a9971215&keyno=0&nosw=1&serpParams=tm%3D1743619645%26tld%3Dru%26lang%3Dru%26name%3Dsat.pdf%26text%3D%25D0%25BA%25D0%25B0%25D0%25BA%2B%25D0%25BB%25D1%2583%25D1%2587%25D1%2588%25D0%25B5%2B%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D1%258C%2B%25D1%2585%25D1%2580%25D0%25B0%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5%2B%25D0%25BA%25D0%25BD%25D1%2584%2B%25D0%25B4%25D0%25BB%25D1%258F%2BSAT%26url%3Dhttps%253A%2F%2Falexanderdyakonov.narod.ru%2Fsat.pdf%26lr%3D213%26mime%3Dpdf%26l10n%3Dru%26sign%3D867f2be1518868eeb2f0be64a9971215%26keyno%3D0%26nosw%3D1  
https://lipen.github.io/sirius-2020/assets/slides/CDCL%20SAT%20solvers.pdf  
https://github.com/niklasso/minisat/blob/master/minisat/simp/Main.cc#L55  
https://pandia.org/text/81/140/3588.php  
https://www.comp.nus.edu.sg/~gregory/sat/  
https://habr.com/ru/articles/207112/  
https://en.wikipedia.org/wiki/DPLL_algorithm  
https://en.m.wikipedia.org/wiki/Conflict-driven_clause_learning  
https://en.m.wikipedia.org/wiki/User:Tamkin04iut  
https://www.cristal.univ-lille.fr/KC/  
